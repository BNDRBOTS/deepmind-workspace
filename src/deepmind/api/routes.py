"""\nFastAPI API routes — Backend endpoints for conversation, connectors, and context.\nThe NiceGUI frontend calls these internally via httpx or directly.\n\nSECURITY: All endpoints require authentication via JWT Bearer token.\nAdmin-level endpoints use require_role("admin") or require_permission().\n"""\nfrom typing import Optional\nfrom fastapi import APIRouter, HTTPException, Query, Request, Response, Depends\nfrom fastapi.responses import JSONResponse, RedirectResponse\nfrom pydantic import BaseModel\n\nfrom deepmind.services.conversation_service import get_conversation_service\nfrom deepmind.services.context_manager import get_context_manager\nfrom deepmind.services.vector_store import get_vector_store\nfrom deepmind.services.code_executor import get_code_executor\nfrom deepmind.services.flux_client import get_flux_client\nfrom deepmind.connectors.registry import get_connector_registry\nfrom deepmind.middleware.auth_middleware import (\n    get_current_user,\n    require_role,\n    require_permission,\n)\nfrom deepmind.models.user import User\n\n\nrouter = APIRouter(prefix="/api", tags=["api"])\n\n\n# ---- Conversation Endpoints ----\n\nclass CreateConversationRequest(BaseModel):\n    title: str = "New Conversation"\n\n\nclass SendMessageRequest(BaseModel):\n    content: str\n\n\nclass PinDocumentRequest(BaseModel):\n    document_id: str\n    source_connector: str\n    document_name: str\n    document_path: str = ""\n\n\n@router.get("/conversations")\nasync def list_conversations(\n    include_archived: bool = False,\n    current_user: User = Depends(get_current_user),\n):\n    svc = get_conversation_service()\n    return await svc.list_conversations(include_archived=include_archived)\n\n\n@router.post("/conversations")\nasync def create_conversation(\n    req: CreateConversationRequest,\n    current_user: User = Depends(get_current_user),\n):\n    svc = get_conversation_service()\n    return await svc.create_conversation(title=req.title)\n\n\n@router.get("/conversations/{conversation_id}/messages")\nasync def get_messages(\n    conversation_id: str,\n    current_user: User = Depends(get_current_user),\n):\n    svc = get_conversation_service()\n    return await svc.get_conversation_messages(conversation_id)\n\n\n@router.post("/conversations/{conversation_id}/messages")\nasync def send_message(\n    conversation_id: str,\n    req: SendMessageRequest,\n    current_user: User = Depends(get_current_user),\n):\n    svc = get_conversation_service()\n    response_text = await svc.send_message_sync(conversation_id, req.content)\n    return {"content": response_text}\n\n\n@router.delete("/conversations/{conversation_id}")\nasync def delete_conversation(\n    conversation_id: str,\n    current_user: User = Depends(get_current_user),\n):\n    svc = get_conversation_service()\n    await svc.delete_conversation(conversation_id)\n    return {"status": "deleted"}\n\n\n# ---- Context Endpoints ----\n\n@router.get("/conversations/{conversation_id}/context")\nasync def get_context_stats(\n    conversation_id: str,\n    current_user: User = Depends(get_current_user),\n):\n    ctx = get_context_manager()\n    return await ctx.get_context_stats(conversation_id)\n\n\n# ---- Document Pin Endpoints ----\n\n@router.post("/conversations/{conversation_id}/pins")\nasync def pin_document(\n    conversation_id: str,\n    req: PinDocumentRequest,\n    current_user: User = Depends(get_current_user),\n):\n    svc = get_conversation_service()\n    return await svc.pin_document(\n        conversation_id=conversation_id,\n        document_id=req.document_id,\n        source_connector=req.source_connector,\n        document_name=req.document_name,\n        document_path=req.document_path,\n    )\n\n\n@router.delete("/pins/{pin_id}")\nasync def unpin_document(\n    pin_id: str,\n    current_user: User = Depends(get_current_user),\n):\n    svc = get_conversation_service()\n    await svc.unpin_document(pin_id)\n    return {"status": "unpinned"}\n\n\n# ---- Code Execution Endpoint (requires permission) ----\n\nclass ExecuteCodeRequest(BaseModel):\n    code: str\n    timeout: Optional[int] = None\n\n\n@router.post("/execute-code")\nasync def execute_code(\n    req: ExecuteCodeRequest,\n    current_user: User = Depends(require_permission("code:execute")),\n):\n    \"\"\"\n    Execute Python code in RestrictedPython sandbox.\n    Requires code:execute permission (admin or user role).\n    \"\"\"\n    executor = get_code_executor()\n    result = executor.execute(req.code, timeout_override=req.timeout)\n    return result\n\n\n# ---- Image Generation Endpoint (requires permission) ----\n\nclass GenerateImageRequest(BaseModel):\n    prompt: str\n    model: Optional[str] = None\n    width: Optional[int] = None\n    height: Optional[int] = None\n    steps: Optional[int] = None\n\n\n@router.post("/generate-image")\nasync def generate_image(\n    req: GenerateImageRequest,\n    current_user: User = Depends(require_permission("images:generate")),\n):\n    \"\"\"\n    Generate image using FLUX models via Together AI.\n    Requires images:generate permission (admin or user role).\n    \"\"\"\n    flux = get_flux_client()\n    result = await flux.generate_image(\n        prompt=req.prompt,\n        model=req.model,\n        width=req.width,\n        height=req.height,\n        steps=req.steps,\n    )\n    return result\n\n\n# ---- Connector Endpoints ----\n\n@router.get("/connectors/status")\nasync def connector_status(\n    current_user: User = Depends(get_current_user),\n):\n    registry = get_connector_registry()\n    return await registry.get_all_status()\n\n\n@router.post("/connectors/{connector_name}/connect")\nasync def connect_connector(\n    connector_name: str,\n    current_user: User = Depends(require_role("admin")),\n):\n    registry = get_connector_registry()\n    connector = registry.get(connector_name)\n    if not connector:\n        raise HTTPException(404, f"Connector {connector_name} not found")\n    ok = await connector.connect()\n    return {"connected": ok}\n\n\n@router.get("/connectors/{connector_name}/browse")\nasync def browse_connector(\n    connector_name: str,\n    path: str = "",\n    current_user: User = Depends(get_current_user),\n):\n    registry = get_connector_registry()\n    connector = registry.get(connector_name)\n    if not connector:\n        raise HTTPException(404, f"Connector {connector_name} not found")\n    result = await connector.browse(path)\n    return {\n        "folders": [f.__dict__ for f in result.get("folders", [])],\n        "files": [d.__dict__ for d in result.get("files", [])],\n    }\n\n\n@router.get("/connectors/{connector_name}/search")\nasync def search_connector(\n    connector_name: str,\n    q: str = Query(...),\n    current_user: User = Depends(get_current_user),\n):\n    registry = get_connector_registry()\n    connector = registry.get(connector_name)\n    if not connector:\n        raise HTTPException(404, f"Connector {connector_name} not found")\n    results = await connector.search(q)\n    return [d.__dict__ for d in results]\n\n\n@router.post("/connectors/{connector_name}/sync/{document_id:path}")\nasync def sync_document(\n    connector_name: str,\n    document_id: str,\n    current_user: User = Depends(get_current_user),\n):\n    registry = get_connector_registry()\n    connector = registry.get(connector_name)\n    if not connector:\n        raise HTTPException(404, f"Connector {connector_name} not found")\n    chunk_count = await connector.sync_to_vectors(document_id)\n    return {"document_id": document_id, "chunks_created": chunk_count}\n\n\n# ---- Google Drive OAuth (callback must remain public for redirect) ----\n\n@router.get("/connectors/google/auth")\nasync def google_auth_url(\n    current_user: User = Depends(get_current_user),\n):\n    registry = get_connector_registry()\n    connector = registry.get("google_drive")\n    if not connector or not hasattr(connector, "get_oauth_url"):\n        raise HTTPException(400, "Google Drive connector not available")\n    url = connector.get_oauth_url()\n    return {"auth_url": url}\n\n\n@router.get("/connectors/google/callback")\nasync def google_callback(code: str = Query(...)):\n    \"\"\"OAuth callback — must remain public for Google redirect.\"\"\"\n    registry = get_connector_registry()\n    connector = registry.get("google_drive")\n    if not connector or not hasattr(connector, "handle_oauth_callback"):\n        raise HTTPException(400, "Google Drive connector not available")\n    ok = await connector.handle_oauth_callback(code)\n    if ok:\n        return RedirectResponse("/?google_auth=success")\n    raise HTTPException(400, "OAuth failed")\n\n\n# ---- Vector Store ----\n\n@router.get("/vectors/stats")\nasync def vector_stats(\n    current_user: User = Depends(require_role("admin")),\n):\n    store = get_vector_store()\n    collections = ["connector_github", "connector_dropbox", "connector_google_drive"]\n    stats = {}\n    for name in collections:\n        stats[name] = store.get_collection_stats(name)\n    return stats\n\n\n@router.post("/vectors/query")\nasync def vector_query(\n    collection: str = "connector_github",\n    q: str = Query(...),\n    n: int = 5,\n    current_user: User = Depends(get_current_user),\n):\n    store = get_vector_store()\n    results = store.query(collection_name=collection, query_text=q, n_results=n)\n    return results\n