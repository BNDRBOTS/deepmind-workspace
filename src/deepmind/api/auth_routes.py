"""\nAuthentication API Routes — Login, Register, Logout, Token Refresh.\nEnterprise-grade with Pydantic validation, proper error handling.\n"""\nfrom typing import Optional\nfrom fastapi import APIRouter, HTTPException, status, Depends, Request\nfrom pydantic import BaseModel, EmailStr, Field, field_validator\nimport structlog\n\nfrom deepmind.services.auth_service import get_auth_service, AuthService\nfrom deepmind.middleware.auth_middleware import get_current_user\nfrom deepmind.models.user import User\n\nlog = structlog.get_logger()\n\nrouter = APIRouter(prefix="/auth", tags=["authentication"])\n\n\n# ---- Request/Response Models ----\n\nclass RegisterRequest(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50, pattern=r"^[a-zA-Z0-9_-]+$")\n    email: EmailStr\n    password: str = Field(..., min_length=8, max_length=100)\n    full_name: Optional[str] = Field(None, max_length=100)\n\n    @field_validator("password")\n    @classmethod\n    def password_strength(cls, v: str) -> str:\n        \"\"\"Validate password strength — uppercase, lowercase, digit required.\"\"\"\n        if not any(c.isupper() for c in v):\n            raise ValueError("Password must contain at least one uppercase letter")\n        if not any(c.islower() for c in v):\n            raise ValueError("Password must contain at least one lowercase letter")\n        if not any(c.isdigit() for c in v):\n            raise ValueError("Password must contain at least one digit")\n        return v\n\n\nclass LoginRequest(BaseModel):\n    username: str = Field(..., min_length=1)\n    password: str = Field(..., min_length=1)\n\n\nclass RefreshRequest(BaseModel):\n    refresh_token: str = Field(...)\n\n\nclass TokenResponse(BaseModel):\n    access_token: str\n    refresh_token: str\n    token_type: str = "bearer"\n    expires_in: int = 900  # 15 minutes in seconds\n\n\nclass UserResponse(BaseModel):\n    id: str\n    username: str\n    email: str\n    full_name: Optional[str]\n    is_active: bool\n    is_superuser: bool\n    roles: list[str]\n\n    class Config:\n        from_attributes = True\n\n\n# ---- Endpoints ----\n\n@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)\nasync def register(req: RegisterRequest, auth: AuthService = Depends(get_auth_service)):\n    \"\"\"\n    Register new user.\n\n    - **username**: 3-50 chars, alphanumeric + underscore/dash\n    - **email**: Valid email address\n    - **password**: Min 8 chars, must contain upper, lower, digit\n    - **full_name**: Optional display name\n\n    Returns access + refresh tokens immediately after registration.\n    \"\"\"\n    try:\n        user = await auth.create_user(\n            username=req.username,\n            email=req.email,\n            password=req.password,\n            full_name=req.full_name,\n        )\n    except ValueError as e:\n        log.warning("registration_failed", error=str(e), username=req.username)\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e),\n        )\n\n    tokens = auth.create_token_pair(user)\n    log.info("user_registered", user_id=user.id, username=user.username)\n\n    return TokenResponse(\n        access_token=tokens["access_token"],\n        refresh_token=tokens["refresh_token"],\n    )\n\n\n@router.post("/login", response_model=TokenResponse)\nasync def login(req: LoginRequest, request: Request, auth: AuthService = Depends(get_auth_service)):\n    \"\"\"\n    Login with username/email and password.\n\n    Accepts either username or email in the `username` field.\n    Records login attempts for security auditing and lockout enforcement.\n\n    Returns access + refresh tokens on success.\n    \"\"\"\n    # Extract client IP for audit trail\n    ip_address = request.client.host if request.client else None\n\n    user = await auth.authenticate_user(req.username, req.password, ip_address=ip_address)\n\n    if not user:\n        log.warning("login_failed", username=req.username)\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail="Incorrect username or password",\n            headers={"WWW-Authenticate": "Bearer"},\n        )\n\n    tokens = auth.create_token_pair(user)\n\n    return TokenResponse(\n        access_token=tokens["access_token"],\n        refresh_token=tokens["refresh_token"],\n    )\n\n\n@router.post("/refresh", response_model=TokenResponse)\nasync def refresh_token(req: RefreshRequest, auth: AuthService = Depends(get_auth_service)):\n    \"\"\"\n    Refresh access token using refresh token.\n\n    - Validates refresh token signature and expiration\n    - Returns new access + refresh token pair\n    - Old refresh token should be discarded by client\n    \"\"\"\n    payload = auth.verify_token(req.refresh_token, token_type="refresh")\n\n    if not payload:\n        log.warning("refresh_failed", reason="invalid_token")\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail="Invalid or expired refresh token",\n            headers={"WWW-Authenticate": "Bearer"},\n        )\n\n    user_id = payload.get("sub")\n    user = await auth.get_user_by_id(user_id)\n\n    if not user or not user.is_active:\n        log.warning("refresh_failed", reason="user_inactive", user_id=user_id)\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail="User not found or inactive",\n        )\n\n    tokens = auth.create_token_pair(user)\n\n    return TokenResponse(\n        access_token=tokens["access_token"],\n        refresh_token=tokens["refresh_token"],\n    )\n\n\n@router.post("/logout")\nasync def logout():\n    \"\"\"\n    Logout (client-side token deletion).\n\n    Server-side token blacklisting requires Redis — implement in Phase 2.\n    Client must delete both access and refresh tokens from storage.\n    \"\"\"\n    return {"message": "Logged out successfully. Delete tokens from client storage."}\n\n\n@router.get("/me", response_model=UserResponse)\nasync def get_current_user_info(current_user: User = Depends(get_current_user)):\n    \"\"\"\n    Get current authenticated user info.\n\n    Requires valid access token in Authorization header.\n    \"\"\"\n    return UserResponse(\n        id=str(current_user.id),\n        username=current_user.username,\n        email=current_user.email,\n        full_name=current_user.full_name,\n        is_active=current_user.is_active,\n        is_superuser=current_user.is_superuser,\n        roles=[role.name for role in current_user.roles],\n    )\n