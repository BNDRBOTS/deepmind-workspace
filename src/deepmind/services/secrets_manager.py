"""\nSecrets Manager \u2014 Abstract provider interface for enterprise secrets management.\nSupports HashiCorp Vault, AWS Secrets Manager, and local encrypted file backends.\n\nUsage:\n    from deepmind.services.secrets_manager import get_secrets_manager\n    sm = get_secrets_manager()\n    api_key = sm.get(\"DEEPSEEK_API_KEY\")\n\nThe active provider is determined by config/app.yaml \u2192 secrets.provider.\nFalls back to environment variables when no external provider is configured.\n"""\nimport os\nimport json\nimport base64\nfrom abc import ABC, abstractmethod\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any\nimport structlog\n\nfrom deepmind.config import get_config\n\nlog = structlog.get_logger()\n\n\nclass SecretsProvider(ABC):\n    \"\"\"Abstract base class for secrets providers.\"\"\"\n\n    @abstractmethod\n    def get(self, key: str, default: Optional[str] = None) -> Optional[str]:\n        \"\"\"Retrieve a secret by key name.\"\"\"\n        ...\n\n    @abstractmethod\n    def set(self, key: str, value: str) -> None:\n        \"\"\"Store a secret (write-capable providers only).\"\"\"\n        ...\n\n    @abstractmethod\n    def exists(self, key: str) -> bool:\n        \"\"\"Check if a secret exists.\"\"\"\n        ...\n\n    @abstractmethod\n    def delete(self, key: str) -> None:\n        \"\"\"Delete a secret.\"\"\"\n        ...\n\n    @abstractmethod\n    def list_keys(self) -> list[str]:\n        \"\"\"List all available secret keys.\"\"\"\n        ...\n\n    @abstractmethod\n    def health_check(self) -> bool:\n        \"\"\"Verify provider connectivity.\"\"\"\n        ...\n\n\nclass EnvironmentSecretsProvider(SecretsProvider):\n    \"\"\"\n    Secrets from environment variables.\n    Default provider \u2014 zero config, works everywhere.\n    Config values from app.yaml take precedence via get_config().\n    \"\"\"\n\n    def __init__(self):\n        self._cfg = get_config()\n        # Map of secret names to config attribute paths\n        self._config_map: Dict[str, tuple] = {\n            \"DEEPSEEK_API_KEY\": (\"deepseek\", \"api_key\"),\n            \"OPENAI_API_KEY\": (\"openai\", \"api_key\"),\n            \"TOGETHER_API_KEY\": (\"image_generation\", \"api_key\"),\n            \"APP_SECRET_KEY\": (\"app\", \"secret_key\"),\n            \"GITHUB_TOKEN\": (\"connectors\", \"github\", \"token\"),\n            \"DROPBOX_APP_KEY\": (\"connectors\", \"dropbox\", \"app_key\"),\n            \"DROPBOX_APP_SECRET\": (\"connectors\", \"dropbox\", \"app_secret\"),\n            \"DROPBOX_REFRESH_TOKEN\": (\"connectors\", \"dropbox\", \"refresh_token\"),\n            \"GOOGLE_CLIENT_ID\": (\"connectors\", \"google_drive\", \"client_id\"),\n            \"GOOGLE_CLIENT_SECRET\": (\"connectors\", \"google_drive\", \"client_secret\"),\n        }\n\n    def _resolve_from_config(self, key: str) -> Optional[str]:\n        \"\"\"Walk the config object to resolve a key.\"\"\"\n        path = self._config_map.get(key)\n        if not path:\n            return None\n        obj = self._cfg\n        for attr in path:\n            obj = getattr(obj, attr, None)\n            if obj is None:\n                return None\n        val = str(obj) if obj else None\n        return val if val and val.strip() else None\n\n    def get(self, key: str, default: Optional[str] = None) -> Optional[str]:\n        \"\"\"\n        Resolve secret: config object first, then env var, then default.\n        Config object values come from app.yaml with ${VAR} interpolation,\n        so they already incorporate env vars. Direct env lookup is fallback.\n        \"\"\"\n        # 1. Config object (already resolved from YAML + env interpolation)\n        config_val = self._resolve_from_config(key)\n        if config_val:\n            return config_val\n\n        # 2. Direct environment variable\n        env_val = os.environ.get(key)\n        if env_val and env_val.strip():\n            return env_val\n\n        return default\n\n    def set(self, key: str, value: str) -> None:\n        \"\"\"Set env var (process-scoped only, not persistent).\"\"\"\n        os.environ[key] = value\n\n    def exists(self, key: str) -> bool:\n        return self.get(key) is not None\n\n    def delete(self, key: str) -> None:\n        os.environ.pop(key, None)\n\n    def list_keys(self) -> list[str]:\n        return list(self._config_map.keys())\n\n    def health_check(self) -> bool:\n        return True\n\n\nclass VaultSecretsProvider(SecretsProvider):\n    \"\"\"\n    HashiCorp Vault secrets provider.\n    Uses the hvac Python client for KV v2 secrets engine.\n\n    Config:\n        secrets.vault_url: Vault server URL\n        secrets.vault_token: Auth token (or VAULT_TOKEN env)\n        secrets.vault_mount: KV mount path (default: \"secret\")\n        secrets.vault_path: Path prefix (default: \"deepmind\")\n    \"\"\"\n\n    def __init__(self):\n        cfg = get_config()\n        secrets_cfg = getattr(cfg, \"secrets\", None)\n\n        self._url = getattr(secrets_cfg, \"vault_url\", \"\") if secrets_cfg else \"\"\n        self._token = os.environ.get(\"VAULT_TOKEN\", \"\")\n        self._mount = getattr(secrets_cfg, \"vault_mount\", \"secret\") if secrets_cfg else \"secret\"\n        self._path = getattr(secrets_cfg, \"vault_path\", \"deepmind\") if secrets_cfg else \"deepmind\"\n        self._client = None\n        self._cache: Dict[str, str] = {}\n\n        if not self._url:\n            raise ValueError(\"secrets.vault_url must be configured for Vault provider\")\n\n    def _get_client(self):\n        if self._client is None:\n            try:\n                import hvac\n                self._client = hvac.Client(url=self._url, token=self._token)\n                if not self._client.is_authenticated():\n                    raise ConnectionError(\"Vault authentication failed\")\n                log.info(\"vault_connected\", url=self._url)\n            except ImportError:\n                raise ImportError(\n                    \"HashiCorp Vault requires the 'hvac' package. \"\n                    \"Install with: pip install hvac\"\n                )\n        return self._client\n\n    def _read_all(self) -> Dict[str, str]:\n        \"\"\"Read all secrets from Vault path, cache locally.\"\"\"\n        if self._cache:\n            return self._cache\n        try:\n            client = self._get_client()\n            response = client.secrets.kv.v2.read_secret_version(\n                path=self._path, mount_point=self._mount\n            )\n            self._cache = response[\"data\"][\"data\"]\n            return self._cache\n        except Exception as e:\n            log.error(\"vault_read_error\", error=str(e))\n            return {}\n\n    def get(self, key: str, default: Optional[str] = None) -> Optional[str]:\n        secrets = self._read_all()\n        return secrets.get(key, default)\n\n    def set(self, key: str, value: str) -> None:\n        try:\n            client = self._get_client()\n            secrets = self._read_all()\n            secrets[key] = value\n            client.secrets.kv.v2.create_or_update_secret(\n                path=self._path, secret=secrets, mount_point=self._mount\n            )\n            self._cache[key] = value\n            log.info(\"vault_secret_set\", key=key)\n        except Exception as e:\n            log.error(\"vault_write_error\", key=key, error=str(e))\n            raise\n\n    def exists(self, key: str) -> bool:\n        return key in self._read_all()\n\n    def delete(self, key: str) -> None:\n        secrets = self._read_all()\n        secrets.pop(key, None)\n        try:\n            client = self._get_client()\n            client.secrets.kv.v2.create_or_update_secret(\n                path=self._path, secret=secrets, mount_point=self._mount\n            )\n            self._cache.pop(key, None)\n        except Exception as e:\n            log.error(\"vault_delete_error\", key=key, error=str(e))\n\n    def list_keys(self) -> list[str]:\n        return list(self._read_all().keys())\n\n    def health_check(self) -> bool:\n        try:\n            client = self._get_client()\n            return client.sys.is_initialized() and not client.sys.is_sealed()\n        except Exception:\n            return False\n\n\nclass AWSSecretsProvider(SecretsProvider):\n    \"\"\"\n    AWS Secrets Manager provider.\n    Stores all secrets in a single JSON secret object.\n\n    Config:\n        secrets.aws_region: AWS region (default: us-east-1)\n        secrets.aws_secret_name: Secret name in AWS (default: deepmind/secrets)\n    \"\"\"\n\n    def __init__(self):\n        cfg = get_config()\n        secrets_cfg = getattr(cfg, \"secrets\", None)\n\n        self._region = getattr(secrets_cfg, \"aws_region\", \"us-east-1\") if secrets_cfg else \"us-east-1\"\n        self._secret_name = getattr(secrets_cfg, \"aws_secret_name\", \"deepmind/secrets\") if secrets_cfg else \"deepmind/secrets\"\n        self._client = None\n        self._cache: Dict[str, str] = {}\n\n    def _get_client(self):\n        if self._client is None:\n            try:\n                import boto3\n                self._client = boto3.client(\"secretsmanager\", region_name=self._region)\n                log.info(\"aws_secrets_connected\", region=self._region)\n            except ImportError:\n                raise ImportError(\n                    \"AWS Secrets Manager requires the 'boto3' package. \"\n                    \"Install with: pip install boto3\"\n                )\n        return self._client\n\n    def _read_all(self) -> Dict[str, str]:\n        if self._cache:\n            return self._cache\n        try:\n            client = self._get_client()\n            response = client.get_secret_value(SecretId=self._secret_name)\n            self._cache = json.loads(response[\"SecretString\"])\n            return self._cache\n        except Exception as e:\n            log.error(\"aws_secrets_read_error\", error=str(e))\n            return {}\n\n    def get(self, key: str, default: Optional[str] = None) -> Optional[str]:\n        return self._read_all().get(key, default)\n\n    def set(self, key: str, value: str) -> None:\n        secrets = self._read_all()\n        secrets[key] = value\n        try:\n            client = self._get_client()\n            client.update_secret(\n                SecretId=self._secret_name,\n                SecretString=json.dumps(secrets),\n            )\n            self._cache[key] = value\n        except Exception as e:\n            log.error(\"aws_secrets_write_error\", key=key, error=str(e))\n            raise\n\n    def exists(self, key: str) -> bool:\n        return key in self._read_all()\n\n    def delete(self, key: str) -> None:\n        secrets = self._read_all()\n        secrets.pop(key, None)\n        try:\n            client = self._get_client()\n            client.update_secret(\n                SecretId=self._secret_name,\n                SecretString=json.dumps(secrets),\n            )\n            self._cache.pop(key, None)\n        except Exception:\n            pass\n\n    def list_keys(self) -> list[str]:\n        return list(self._read_all().keys())\n\n    def health_check(self) -> bool:\n        try:\n            client = self._get_client()\n            client.describe_secret(SecretId=self._secret_name)\n            return True\n        except Exception:\n            return False\n\n\nclass LocalEncryptedSecretsProvider(SecretsProvider):\n    \"\"\"\n    Local encrypted file secrets provider.\n    Uses Fernet symmetric encryption (AES-128-CBC via cryptography library).\n\n    Config:\n        secrets.local_encrypted_path: File path (default: data/.secrets.enc)\n\n    The encryption key is derived from APP_SECRET_KEY via PBKDF2.\n    \"\"\"\n\n    def __init__(self):\n        cfg = get_config()\n        secrets_cfg = getattr(cfg, \"secrets\", None)\n\n        path_str = getattr(secrets_cfg, \"local_encrypted_path\", \"data/.secrets.enc\") if secrets_cfg else \"data/.secrets.enc\"\n        self._path = Path(path_str)\n        self._fernet = None\n        self._cache: Dict[str, str] = {}\n\n        # Derive encryption key from APP_SECRET_KEY\n        master_key = cfg.app.secret_key\n        if not master_key or len(master_key) < 32:\n            raise ValueError(\"APP_SECRET_KEY must be set (min 32 chars) for local_encrypted provider\")\n\n        self._init_fernet(master_key)\n\n    def _init_fernet(self, master_key: str) -> None:\n        try:\n            from cryptography.fernet import Fernet\n            from cryptography.hazmat.primitives import hashes\n            from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n\n            kdf = PBKDF2HMAC(\n                algorithm=hashes.SHA256(),\n                length=32,\n                salt=b\"deepmind-workspace-secrets-v1\",\n                iterations=480000,\n            )\n            key = base64.urlsafe_b64encode(kdf.derive(master_key.encode()))\n            self._fernet = Fernet(key)\n        except ImportError:\n            raise ImportError(\n                \"Local encrypted secrets requires the 'cryptography' package. \"\n                \"Install with: pip install cryptography\"\n            )\n\n    def _load(self) -> Dict[str, str]:\n        if self._cache:\n            return self._cache\n        if not self._path.exists():\n            return {}\n        try:\n            encrypted = self._path.read_bytes()\n            decrypted = self._fernet.decrypt(encrypted)\n            self._cache = json.loads(decrypted)\n            return self._cache\n        except Exception as e:\n            log.error(\"local_secrets_load_error\", error=str(e))\n            return {}\n\n    def _save(self) -> None:\n        self._path.parent.mkdir(parents=True, exist_ok=True)\n        plaintext = json.dumps(self._cache, indent=2).encode()\n        encrypted = self._fernet.encrypt(plaintext)\n        self._path.write_bytes(encrypted)\n\n    def get(self, key: str, default: Optional[str] = None) -> Optional[str]:\n        return self._load().get(key, default)\n\n    def set(self, key: str, value: str) -> None:\n        self._load()\n        self._cache[key] = value\n        self._save()\n\n    def exists(self, key: str) -> bool:\n        return key in self._load()\n\n    def delete(self, key: str) -> None:\n        self._load()\n        self._cache.pop(key, None)\n        self._save()\n\n    def list_keys(self) -> list[str]:\n        return list(self._load().keys())\n\n    def health_check(self) -> bool:\n        try:\n            self._load()\n            return True\n        except Exception:\n            return False\n\n\n# ============================================================================\n# Factory + Singleton\n# ============================================================================\n\n_secrets_manager: Optional[SecretsProvider] = None\n\n\ndef _create_provider() -> SecretsProvider:\n    \"\"\"Create secrets provider based on config.\"\"\"\n    cfg = get_config()\n    secrets_cfg = getattr(cfg, \"secrets\", None)\n    provider_name = getattr(secrets_cfg, \"provider\", \"environment\") if secrets_cfg else \"environment\"\n\n    providers = {\n        \"environment\": EnvironmentSecretsProvider,\n        \"vault\": VaultSecretsProvider,\n        \"aws\": AWSSecretsProvider,\n        \"local_encrypted\": LocalEncryptedSecretsProvider,\n    }\n\n    provider_cls = providers.get(provider_name)\n    if not provider_cls:\n        raise ValueError(\n            f\"Unknown secrets provider: {provider_name}. \"\n            f\"Valid options: {list(providers.keys())}\"\n        )\n\n    log.info(\"secrets_provider_init\", provider=provider_name)\n    return provider_cls()\n\n\ndef get_secrets_manager() -> SecretsProvider:\n    \"\"\"Get the singleton secrets manager instance.\"\"\"\n    global _secrets_manager\n    if _secrets_manager is None:\n        _secrets_manager = _create_provider()\n    return _secrets_manager\n\n\ndef reset_secrets_manager() -> None:\n    \"\"\"Reset singleton (for testing).\"\"\"\n    global _secrets_manager\n    _secrets_manager = None\n