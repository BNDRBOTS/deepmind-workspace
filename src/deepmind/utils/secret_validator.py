"""\nStartup Secret Validator \u2014 Validates all critical secrets before the app boots.\nRaises SystemExit if validation fails. Called from config.py during load_config().\n\nChecks:\n- APP_SECRET_KEY is not a default/placeholder value\n- APP_SECRET_KEY meets minimum length (32 chars)\n- APP_SECRET_KEY has sufficient Shannon entropy (>3.5 bits/char)\n- JWT_SECRET_KEY present and valid when auth is enabled\n- Critical API keys are present for enabled services\n"""\nimport os\nimport math\nimport sys\nfrom collections import Counter\nfrom typing import List, Tuple\nimport structlog\n\nlog = structlog.get_logger()\n\n# Known placeholder/default values that must be rejected\n_BANNED_SECRET_VALUES = frozenset({\n    \"\",\n    \"change-this-to-a-secure-random-string-min-32-chars\",\n    \"generate-with-openssl-rand-hex-64-min-32-chars\",\n    \"generate-separate-key-for-refresh-tokens\",\n    \"your_secret_key_here\",\n    \"secret\",\n    \"changeme\",\n    \"password\",\n    \"default\",\n    \"test\",\n    \"12345678901234567890123456789012\",\n    \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n})\n\n\ndef _shannon_entropy(data: str) -> float:\n    \"\"\"\n    Calculate Shannon entropy in bits per character.\n    A truly random base64 string of 64 chars \u2248 5.8-6.0 bits/char.\n    Minimum acceptable: 3.5 bits/char (rejects keyboard-mashed garbage).\n    \"\"\"\n    if not data:\n        return 0.0\n    length = len(data)\n    freq = Counter(data)\n    return -sum((count / length) * math.log2(count / length) for count in freq.values())\n\n\ndef _check_secret_key(\n    key_name: str,\n    value: str,\n    min_length: int = 32,\n    min_entropy: float = 3.5,\n    required: bool = True,\n) -> List[str]:\n    \"\"\"\n    Validate a single secret key.\n\n    Returns:\n        List of error strings (empty = passed).\n    \"\"\"\n    errors: List[str] = []\n\n    if not value or not value.strip():\n        if required:\n            errors.append(\n                f\"  \u2717 {key_name} is not set. \"\n                f\"Generate with: python scripts/generate_secrets.py\"\n            )\n        return errors\n\n    cleaned = value.strip()\n\n    # Check against banned values\n    if cleaned.lower() in _BANNED_SECRET_VALUES or cleaned in _BANNED_SECRET_VALUES:\n        errors.append(\n            f\"  \u2717 {key_name} is set to a default/placeholder value. \"\n            f\"Generate a real key: python scripts/generate_secrets.py\"\n        )\n        return errors\n\n    # Check minimum length\n    if len(cleaned) < min_length:\n        errors.append(\n            f\"  \u2717 {key_name} is too short ({len(cleaned)} chars, minimum {min_length}). \"\n            f\"Generate with: python scripts/generate_secrets.py\"\n        )\n\n    # Check entropy\n    entropy = _shannon_entropy(cleaned)\n    if entropy < min_entropy:\n        errors.append(\n            f\"  \u2717 {key_name} has insufficient entropy ({entropy:.2f} bits/char, minimum {min_entropy}). \"\n            f\"Use a cryptographically random value: python scripts/generate_secrets.py\"\n        )\n\n    return errors\n\n\ndef validate_secrets_on_startup(config) -> None:\n    \"\"\"\n    Validate all critical secrets at startup.\n    Called from load_config() after config is fully parsed.\n\n    Args:\n        config: Fully loaded Config object\n\n    Raises:\n        SystemExit: If any critical secret validation fails in production\n    \"\"\"\n    errors: List[str] = []\n    warnings: List[str] = []\n    is_production = config.app.env.lower() in (\"production\", \"prod\", \"staging\")\n\n    # ---- APP_SECRET_KEY (always required) ----\n    errors.extend(\n        _check_secret_key(\n            \"APP_SECRET_KEY\",\n            config.app.secret_key,\n            min_length=32,\n            min_entropy=3.5,\n            required=True,\n        )\n    )\n\n    # ---- JWT_SECRET_KEY (required when auth middleware is active) ----\n    jwt_key = os.environ.get(\"JWT_SECRET_KEY\", \"\")\n    jwt_errors = _check_secret_key(\n        \"JWT_SECRET_KEY\",\n        jwt_key,\n        min_length=32,\n        min_entropy=3.5,\n        required=False,  # Falls back to APP_SECRET_KEY\n    )\n    if jwt_errors:\n        # Not a hard error \u2014 falls back to APP_SECRET_KEY\n        for e in jwt_errors:\n            warnings.append(e.replace(\"\u2717\", \"\u26a0\") + \" (falling back to APP_SECRET_KEY)\")\n\n    # ---- API Keys (warn if missing, not fatal) ----\n    api_keys = [\n        (\"DEEPSEEK_API_KEY\", config.deepseek.api_key, \"DeepSeek chat will not function\"),\n        (\"OPENAI_API_KEY\", config.openai.api_key, \"OpenAI GPT-4o will not function\"),\n        (\"TOGETHER_API_KEY\", config.image_generation.api_key, \"Image generation will not function\"),\n    ]\n    for key_name, value, impact in api_keys:\n        if not value or not value.strip() or value.startswith(\"your_\"):\n            warnings.append(f\"  \u26a0 {key_name} not configured \u2014 {impact}\")\n\n    # ---- Connector tokens (warn if enabled but missing) ----\n    if config.connectors.github.enabled and not config.connectors.github.token:\n        warnings.append(\"  \u26a0 GITHUB_TOKEN not set \u2014 GitHub connector will fail to connect\")\n\n    # ---- Output results ----\n    if warnings:\n        log.warning(\n            \"secret_validation_warnings\",\n            count=len(warnings),\n            details=\"\\n\".join(warnings),\n        )\n        print(\"\\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\", file=sys.stderr)\n        print(\"\u2551  \u26a0  SECRET VALIDATION WARNINGS                              \u2551\", file=sys.stderr)\n        print(\"\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\", file=sys.stderr)\n        for w in warnings:\n            print(f\"\u2551 {w:<60s} \u2551\", file=sys.stderr)\n        print(\"\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\\n\", file=sys.stderr)\n\n    if errors:\n        log.critical(\n            \"secret_validation_failed\",\n            count=len(errors),\n            details=\"\\n\".join(errors),\n        )\n        print(\"\\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\", file=sys.stderr)\n        print(\"\u2551  \u2717  FATAL: SECRET VALIDATION FAILED                         \u2551\", file=sys.stderr)\n        print(\"\u2551     Application cannot start with insecure configuration.    \u2551\", file=sys.stderr)\n        print(\"\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\", file=sys.stderr)\n        for e in errors:\n            print(f\"\u2551 {e:<60s} \u2551\", file=sys.stderr)\n        print(\"\u2551                                                              \u2551\", file=sys.stderr)\n        print(\"\u2551  Fix: python scripts/generate_secrets.py                     \u2551\", file=sys.stderr)\n        print(\"\u2551       Copy output to .env file                               \u2551\", file=sys.stderr)\n        print(\"\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\\n\", file=sys.stderr)\n\n        if is_production:\n            raise SystemExit(\n                \"FATAL: Secret validation failed. \"\n                \"Run 'python scripts/generate_secrets.py' and configure .env. \"\n                \"See errors above.\"\n            )\n        else:\n            log.warning(\n                \"secret_validation_bypassed\",\n                message=\"Running in development mode \u2014 secret validation errors are non-fatal. \"\n                        \"Fix before deploying to production.\",\n            )\n