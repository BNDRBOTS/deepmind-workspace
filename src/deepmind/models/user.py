"""\nEnterprise-grade User and Role SQLAlchemy models with bcrypt password hashing.\nSecurity hardened with audit trails, account lockout, and password policies.\n\nCRITICAL: Uses shared Base from conversation.py â€” required for database.py init_database()\n          to create these tables alongside conversation tables.\n"""\nimport json\nimport uuid\nfrom datetime import datetime, timezone\nfrom typing import Optional, List\n\nfrom sqlalchemy import (\n    Boolean, Column, DateTime, ForeignKey, Integer, String, Text, Table, JSON\n)\nfrom sqlalchemy.orm import relationship\nimport bcrypt\n\nfrom deepmind.models.conversation import Base\n\n\n# Association table for many-to-many User-Role relationship\nuser_roles = Table(\n    "user_roles",\n    Base.metadata,\n    Column("user_id", String(36), ForeignKey("users.id", ondelete="CASCADE"), primary_key=True),\n    Column("role_id", String(36), ForeignKey("roles.id", ondelete="CASCADE"), primary_key=True),\n)\n\n\nclass Role(Base):\n    \"\"\"\n    Role-based access control model.\n    Granular permission booleans for enterprise RBAC.\n    \"\"\"\n    __tablename__ = "roles"\n\n    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))\n    name = Column(String(50), unique=True, nullable=False, index=True)\n    description = Column(String(255), nullable=True)\n\n    # Granular permission flags\n    can_execute_code = Column(Boolean, default=False, nullable=False)\n    can_generate_images = Column(Boolean, default=False, nullable=False)\n    can_manage_users = Column(Boolean, default=False, nullable=False)\n    can_access_all_conversations = Column(Boolean, default=False, nullable=False)\n\n    created_at = Column(\n        DateTime, default=lambda: datetime.now(timezone.utc), nullable=False\n    )\n\n    # Relationships\n    users = relationship("User", secondary=user_roles, back_populates="roles", lazy="selectin")\n\n    def __repr__(self) -> str:\n        return f"<Role(id={self.id}, name='{self.name}')>"\n\n    def has_permission(self, permission: str) -> bool:\n        \"\"\"Check if role has specific permission by attribute name.\"\"\"\n        perm_map = {\n            "code:execute": self.can_execute_code,\n            "images:generate": self.can_generate_images,\n            "users:manage": self.can_manage_users,\n            "conversations:all": self.can_access_all_conversations,\n            "*": self.can_manage_users,  # admin wildcard\n        }\n        return perm_map.get(permission, False)\n\n\nclass User(Base):\n    \"\"\"\n    Enterprise user model with comprehensive security features:\n    - Bcrypt password hashing (cost factor 12)\n    - Account lockout after 5 failed attempts\n    - Email verification workflow\n    - Soft delete support\n    - Comprehensive audit trail\n\n    All IDs are String(36) UUIDs for consistency across the codebase.\n    \"\"\"\n    __tablename__ = "users"\n\n    # Primary identification\n    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))\n    username = Column(String(50), unique=True, nullable=False, index=True)\n    email = Column(String(255), unique=True, nullable=False, index=True)\n    password_hash = Column(String(255), nullable=False)\n    full_name = Column(String(255), nullable=True)\n\n    # Account status\n    is_active = Column(Boolean, default=True, nullable=False)\n    is_verified = Column(Boolean, default=False, nullable=False)\n    is_locked = Column(Boolean, default=False, nullable=False)\n    is_superuser = Column(Boolean, default=False, nullable=False)\n\n    # Security tracking\n    failed_login_attempts = Column(Integer, default=0, nullable=False)\n    last_login_at = Column(DateTime, nullable=True)\n    last_login_ip = Column(String(45), nullable=True)  # IPv6 support\n    last_failed_login = Column(DateTime, nullable=True)\n    locked_at = Column(DateTime, nullable=True)\n\n    # Verification and reset tokens\n    verification_token = Column(String(255), nullable=True)\n    verified_at = Column(DateTime, nullable=True)\n    reset_token = Column(String(255), nullable=True)\n    reset_token_expires = Column(DateTime, nullable=True)\n\n    # Audit timestamps\n    created_at = Column(\n        DateTime, default=lambda: datetime.now(timezone.utc), nullable=False\n    )\n    updated_at = Column(\n        DateTime,\n        default=lambda: datetime.now(timezone.utc),\n        onupdate=lambda: datetime.now(timezone.utc),\n        nullable=False,\n    )\n\n    # Relationships\n    roles = relationship("Role", secondary=user_roles, back_populates="users", lazy="selectin")\n\n    def __repr__(self) -> str:\n        return f"<User(id={self.id}, username='{self.username}', email='{self.email}')>"\n\n    # ---- Password Management ----\n\n    @staticmethod\n    def hash_password(password: str, cost_factor: int = 12) -> str:\n        \"\"\"\n        Hash password using bcrypt with configurable cost factor.\n        Default cost factor 12 = ~300ms on modern hardware.\n\n        Args:\n            password: Plaintext password to hash\n            cost_factor: Bcrypt cost factor (4-31, default 12)\n\n        Returns:\n            Bcrypt hash string (60 chars)\n        \"\"\"\n        if not password or len(password) < 8:\n            raise ValueError("Password must be at least 8 characters")\n\n        salt = bcrypt.gensalt(rounds=cost_factor)\n        return bcrypt.hashpw(password.encode("utf-8"), salt).decode("utf-8")\n\n    def set_password(self, password: str, cost_factor: int = 12) -> None:\n        \"\"\"\n        Set user password with bcrypt hashing.\n\n        Args:\n            password: New plaintext password\n            cost_factor: Bcrypt cost factor (default 12)\n        \"\"\"\n        if not password or len(password) < 8:\n            raise ValueError("Password must be at least 8 characters")\n\n        self.password_hash = self.hash_password(password, cost_factor)\n\n    def verify_password(self, password: str) -> bool:\n        \"\"\"\n        Verify password against stored bcrypt hash.\n        Uses time-constant comparison to prevent timing attacks.\n\n        Args:\n            password: Plaintext password to verify\n\n        Returns:\n            True if password matches, False otherwise\n        \"\"\"\n        if not password or not self.password_hash:\n            return False\n\n        try:\n            return bcrypt.checkpw(\n                password.encode("utf-8"),\n                self.password_hash.encode("utf-8"),\n            )\n        except (ValueError, AttributeError):\n            return False\n\n    # ---- Account Security ----\n\n    def record_login_attempt(self, success: bool, ip_address: Optional[str] = None) -> None:\n        \"\"\"\n        Record login attempt and enforce account lockout policy.\n        Locks account after 5 consecutive failed attempts.\n\n        Args:\n            success: Whether login was successful\n            ip_address: Client IP address for audit trail\n        \"\"\"\n        now = datetime.now(timezone.utc)\n        if success:\n            self.failed_login_attempts = 0\n            self.last_login_at = now\n            self.last_login_ip = ip_address\n            if self.is_locked:\n                self.is_locked = False\n                self.locked_at = None\n        else:\n            self.failed_login_attempts += 1\n            self.last_failed_login = now\n            if self.failed_login_attempts >= 5:\n                self.is_locked = True\n                self.locked_at = now\n\n    def unlock_account(self) -> None:\n        \"\"\"Manually unlock account and reset failed attempts.\"\"\"\n        self.is_locked = False\n        self.failed_login_attempts = 0\n        self.locked_at = None\n\n    # ---- Role Management ----\n\n    def has_role(self, role_name: str) -> bool:\n        \"\"\"Check if user has specific role.\"\"\"\n        return any(role.name == role_name for role in self.roles)\n\n    def has_permission(self, permission: str) -> bool:\n        \"\"\"Check if user has specific permission through any role.\"\"\"\n        if self.is_superuser:\n            return True\n        return any(role.has_permission(permission) for role in self.roles)\n\n    @property\n    def is_admin(self) -> bool:\n        \"\"\"Check if user has admin role or is superuser.\"\"\"\n        return self.is_superuser or self.has_role("admin")\n\n    def soft_delete(self) -> None:\n        \"\"\"Soft delete user account.\"\"\"\n        self.is_active = False\n